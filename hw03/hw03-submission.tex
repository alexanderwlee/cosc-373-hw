\documentclass{amsart}

\usepackage[vlined,linesnumbered]{algorithm2e}
\usepackage{enumitem}

\title{COSC-373: Homework 3}
\author{Lee Jiaen}
\author{Hyery Yoo}
\author{Alexander Lee}

\theoremstyle{definition}
\newtheorem{question}{Question}

\begin{document}

\maketitle

\begin{question}
\begin{enumerate}[label={(\alph*)}]
\item We first use the LE/BFS protocol from class and Diameter protocol from HRW 2 to find the leader, BFS tree, and Diameter (D).
\item Each node then does the following:
    \begin{algorithm}[h]
      \DontPrintSemicolon%
      $local\_counter \gets t_v$\;
      $second\_counter \gets 0$\;
      $status \gets inactive$\;
      $reset\_cntdown \gets D$\;
      \ForEach{round $i \in \{0, 1, \dots, d\}$}{
        \If{$i = 0$}{
          leader sets $status$ = active\;
          leader sends $reset\_cntdown - 1$\ as a message to its neighbors\;
        }
        \If{received messages}{
          set $reset\_cntdown$ = message\;
          set $status$ = active\;
          send $reset\_cntdown - 1$\ as a message to its neighbors\;
        }
        \If{$status$ = active}{
            \If{$second\_counter$ = $reset\_cntdown$}{
            set $local\_counter$ = 0\;
            set $status$ = inactive\;
            }
            \Else {
            $second\_counter$ ++\;
            }
        }
        $local\_counter$ ++\;
      }
      \Return
    \end{algorithm}
    
    (Correctness) The protocol above goes through the BFS tree starting from the leader node, which is found by the LE/BFS protocol discussed in class. After using the Diameter protocol in HRW2, every node will know the diameter and know that it will take D rounds to get from the leader to the furthest away node in the BFS tree. Therefore, the leader decides to wait D rounds until resetting and then letting its neighbors know to wait one less round and then those nodes will let their neighbors know to wait one less round and so on. The message that a node receives, tells the node how many more rounds it will take until we reach the end of the BFS tree. Furthermore, $second\_counter$ and $reset\_cntdown$ help each node to keep track of when to reset and $second\_counter$ only start incriminating after the node has received a message and updated its $status$ to active. In $r_0$ = round D, we would have reached the every node in the BFS tree and the furthest node/nodes from the leader in the BFS tree will be told to wait 0 rounds to reset. Those nodes will then have $second\_counter$ = $reset\_cntdown$ and immediately reset $local\_counter$ to 0. In the same round, every other node in the BFS tree would also have $second\_counter$ = $reset\_cntdown$ and reset $local\_counter$ to 0. BFS, ensures that we reach every node in the graph. Thus, the above protocol is correct because all nodes would reset $local\_counter$ to 0 in $r_0$ = round D. 

      (Runtime) All nodes reset after the message reaches the last furthest node in the BFS. The diameter D of a BFS tree is the distance from the root or leader node to the furthest node of the BFS tree. Therefore, it will take at least D rounds for the leader to notify the furthest away node in the BFS tree that they would like to reset. If we have less than D rounds, then the furthest away nodes would not be notified of the reset and fail to reset at the same time as the other nodes in the BFS tree. Thus, this will take O(D) rounds. We also know that the LE/BFS and Diameter algorithm will take also O(D) rounds. Therefore, this protocol will take O(D) rounds.  
      
      (Congestion) We already know that the CONGEST protocol BE/LFS from class and Diameter protocol from HRW2 send less than $O(nlogn)$ bits. Furthermore, the protocol above has nodes only send messages containing a constant that indicates how many more rounds until a reset, which only require $O(1)$ bits. Therefore, the protocol above is a CONGEST protocol.
\end{enumerate}

\end{question}

\begin{question}
  TODO
\end{question}

\begin{question}
  \begin{enumerate}[label={(\alph*)}]
    \item We proceed with devising a greedy algorithm that is guaranteed to
      produce a proper $\Delta + 1$ coloring of $G$. The algorithm executes as
      follows:
      \begin{enumerate}[label={(\arabic*)}]
        \item Initialize an empty set $C$, which represents the set of colors.
        \item Assign any vertex in $V$ the color 1 and add 1 to $C$.
        \item Choose an uncolored vertex $v \in V$. Assign $v$ the smallest
          color in $C$ that has not been assigned to $v$'s colored neighbors. If
          $v$'s colored neighbors have been assigned all the colors in $C$, add
          a new color $\max\{C\} + 1$ to $C$ and assign it to $v$.
        \item Repeat step (2) until all vertices are colored.
      \end{enumerate}

      Since the algorithm assigns an uncolored vertex $v \in V$ with the lowest
      color in $C$ that has not been assigned to $v$'s neighbors or assigns $v$
      with a new color not yet in $C$, no two neighboring vertices are assigned
      the same color. Furthermore, because the algorithm only adds a new color
      to $C$ when all neighbors of $v$ have been assigned all the colors in $C$
      and $v$ has at most $\Delta$ neighbors, the algorithm adds at most $\Delta
      + 1$ colors to $C$. Thus, only $\Delta + 1$ colors are required.
      Therefore, the algorithm produces a proper $\Delta + 1$ coloring of $G$.

    \item Consider the graph $G_k$ of $\Delta + 1$ vertices, where each vertex
      is connected to every other vertex. In this case, every vertex has a
      degree of $\Delta$, so the maximum degree is $\Delta$. Now, suppose
      towards a contradiction that we have a $\Delta$ proper coloring of $G_k$.
      Thus, at most $\Delta$ colors have been assigned to $\Delta + 1$ vertices
      of $G_k$. By the Pigeonhole Principle, at least two vertices in $G_k$ have
      been assigned the same color. Since every vertex is connected to every
      other vertex, these two vertices with the same color are neighbors. This
      is a contradiction since we assumed that we have a $\Delta$ proper
      coloring of $G_k$, where no two neighboring vertices are assigned the same
      color. Therefore, $G_k$ does not admit a proper $\Delta$ coloring.

    \item Each phase $i$:
      \begin{itemize}
        \item If received message ``halted'' from neighbor in phase $i - 1$
          \begin{itemize}
            \item Remove neighbor from set of neighbors
          \end{itemize}
        \item Execute protocol $\Pi$
        \item If node is in the MIS found from $\Pi$
          \begin{itemize}
            \item Output $i$, send message ``halted'' to neighbors, and halt
          \end{itemize}
      \end{itemize}

      (Correctness) In each phase $i$, protocol $\Pi$ finds a MIS in the network
      of remaining nodes that have not halted. The nodes found in the MIS from
      phase $i$ output color $i$. Neighboring nodes will not output the same
      color since they belong to different maximal independent sets.

      (Runtime) After each phase if a node is not in a MIS, then at least one of
      its neighbors becomes part of an MIS, by the maximality condition.
      As such, after each phase, a node's degree decreases by at least one.
      Since a node has at most $\Delta$ neighbors, at most $\Delta$ phases are
      needed so that all it's neighbors are assigned a color. Hence, each node
      requires at most $\Delta + 1$ phases to output a color $i$. Since each
      phase runs in $T(n)$ rounds, the protocol thus computes a property $\Delta
      + 1$ coloring of $G$ in $O((\Delta + 1) T(n)) = O(\Delta T(n) + T(n)) =
      O(\Delta T(n))$ rounds.

      (Congestion) Since the above protocol uses the CONGEST protocol $\Pi$ and
      apart from in protocol $\Pi$, nodes only send the messages ``halted'' to
      neighbors, which only require $O(1)$ bits, the protocol above is therefore
      a CONGEST protocol.
  \end{enumerate}
\end{question}

\end{document}
